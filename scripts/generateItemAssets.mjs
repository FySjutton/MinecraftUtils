import fs from 'fs'
import path from 'path'

const ASSET_DIR = path.join(process.cwd(), 'public/assets')
const OUT_FILE = path.join(process.cwd(), 'lib/images/itemAssets.ts')
const logAll = process.argv.includes('--all')

if (!fs.existsSync(ASSET_DIR)) {
    console.error(`Missing directory: ${ASSET_DIR}`)
    process.exit(1)
}

const files = []
function walk(dir) {
    for (const e of fs.readdirSync(dir, { withFileTypes: true })) {
        const full = path.join(dir, e.name)
        if (e.isDirectory()) {
            walk(full)
        } else if (e.isFile() && e.name.toLowerCase().endsWith('.png')) {
            const rel = path.relative(ASSET_DIR, full).replace(/\\/g, '/')
            const segments = rel.split('/')
            const filename = path.parse(e.name).name
            files.push({ rel, filename, segments })
        }
    }
}
walk(ASSET_DIR)

const groups = new Map()
for (const f of files) {
    if (!groups.has(f.filename)) groups.set(f.filename, [])
    groups.get(f.filename).push(f)
}

const ITEM_ASSETS = {}
let stats = { unique: 0, renamed: 0, hardErrors: 0 }
const duplicateLog = []
const hardErrorLog = []

for (const [filename, arr] of groups.entries()) {
    if (arr.length === 1) {
        ITEM_ASSETS[filename] = `/assets/${arr[0].rel}`
        stats.unique++
    } else {
        const renamed = arr.map(f => {
            const segs = f.segments
            const namespace = segs.length >= 2 ? segs[segs.length - 2] : segs[0]
            const newKey = `${namespace}_${f.filename}`
            return { ...f, newKey, namespace }
        })

        const collision = new Map()
        for (const r of renamed) {
            if (!collision.has(r.newKey)) collision.set(r.newKey, [])
            collision.get(r.newKey).push(r)
        }

        for (const [newKey, items] of collision.entries()) {
            if (items.length === 1) {
                ITEM_ASSETS[newKey] = `/assets/${items[0].rel}`
                stats.renamed++
                duplicateLog.push({
                    original: filename,
                    renamed: newKey,
                    path: items[0].rel
                })
            } else {
                stats.hardErrors += items.length
                for (const item of items) {
                    hardErrorLog.push({
                        filename,
                        attemptedKey: newKey,
                        namespace: item.namespace,
                        path: item.rel
                    })
                }
            }
        }
    }
}

fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true })
const content = `// --- DO NOT MANUALLY EDIT THIS FILE ---\n// This file is automatically generated using "npm run assets[:all]".\n\nexport const ITEM_ASSETS = ${JSON.stringify(ITEM_ASSETS, null, 2)} as const;
export type MinecraftItemId = keyof typeof ITEM_ASSETS;
`
fs.writeFileSync(OUT_FILE, content)

console.log(`Generated ${OUT_FILE}`)
console.log(`  Unique files: ${stats.unique}`)
console.log(`  Renamed duplicates: ${stats.renamed}`)
console.log(`  Hard errors (skipped): ${stats.hardErrors}`)
console.log(`  Total in list: ${stats.unique + stats.renamed}`)

if (logAll && duplicateLog.length > 0) {
    console.log('\nDUPLICATES (renamed and included):')
    for (const d of duplicateLog) {
        console.log(`  ${d.original} -> ${d.renamed}`)
        console.log(`    ${d.path}`)
    }
}

if (hardErrorLog.length > 0) {
    console.log('\nHARD ERRORS (same namespace, SKIPPED):')
    for (const h of hardErrorLog) {
        console.log(`  ${h.filename} -> ${h.attemptedKey} (namespace: ${h.namespace})`)
        console.log(`    ${h.path}`)
    }
}